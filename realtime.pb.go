// Code generated by protoc-gen-go. DO NOT EDIT.
// source: realtime.proto

package realtime

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type RouteRequest struct {
	Route                string   `protobuf:"bytes,1,opt,name=route,proto3" json:"route,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteRequest) Reset()         { *m = RouteRequest{} }
func (m *RouteRequest) String() string { return proto.CompactTextString(m) }
func (*RouteRequest) ProtoMessage()    {}
func (*RouteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcbdca058206953b, []int{0}
}

func (m *RouteRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RouteRequest.Unmarshal(m, b)
}
func (m *RouteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RouteRequest.Marshal(b, m, deterministic)
}
func (m *RouteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteRequest.Merge(m, src)
}
func (m *RouteRequest) XXX_Size() int {
	return xxx_messageInfo_RouteRequest.Size(m)
}
func (m *RouteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RouteRequest proto.InternalMessageInfo

func (m *RouteRequest) GetRoute() string {
	if m != nil {
		return m.Route
	}
	return ""
}

// A response message containing a greeting
type RouteResponse struct {
	Data                 map[string]string `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	FromCache            bool              `protobuf:"varint,2,opt,name=fromCache,proto3" json:"fromCache,omitempty"`
	CachedDataRemaining  int32             `protobuf:"varint,3,opt,name=cachedDataRemaining,proto3" json:"cachedDataRemaining,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RouteResponse) Reset()         { *m = RouteResponse{} }
func (m *RouteResponse) String() string { return proto.CompactTextString(m) }
func (*RouteResponse) ProtoMessage()    {}
func (*RouteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcbdca058206953b, []int{1}
}

func (m *RouteResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RouteResponse.Unmarshal(m, b)
}
func (m *RouteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RouteResponse.Marshal(b, m, deterministic)
}
func (m *RouteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteResponse.Merge(m, src)
}
func (m *RouteResponse) XXX_Size() int {
	return xxx_messageInfo_RouteResponse.Size(m)
}
func (m *RouteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RouteResponse proto.InternalMessageInfo

func (m *RouteResponse) GetData() map[string]string {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *RouteResponse) GetFromCache() bool {
	if m != nil {
		return m.FromCache
	}
	return false
}

func (m *RouteResponse) GetCachedDataRemaining() int32 {
	if m != nil {
		return m.CachedDataRemaining
	}
	return 0
}

func init() {
	proto.RegisterType((*RouteRequest)(nil), "realtime.RouteRequest")
	proto.RegisterType((*RouteResponse)(nil), "realtime.RouteResponse")
	proto.RegisterMapType((map[string]string)(nil), "realtime.RouteResponse.DataEntry")
}

func init() { proto.RegisterFile("realtime.proto", fileDescriptor_dcbdca058206953b) }

var fileDescriptor_dcbdca058206953b = []byte{
	// 277 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x51, 0xcd, 0x4a, 0xf3, 0x40,
	0x14, 0xfd, 0xa6, 0xf9, 0x2a, 0xcd, 0xb5, 0xfe, 0x30, 0x8a, 0x86, 0xe2, 0x22, 0x06, 0x17, 0x59,
	0x85, 0x52, 0x11, 0xc5, 0x95, 0x50, 0xa5, 0x08, 0xae, 0xa6, 0x4f, 0x70, 0x4d, 0xaf, 0x35, 0xd8,
	0xcc, 0xd4, 0xc9, 0x4d, 0xa1, 0x4f, 0xe9, 0x43, 0xf8, 0x22, 0x32, 0x49, 0x8c, 0x88, 0xba, 0xd1,
	0xdd, 0x3d, 0x33, 0x67, 0xee, 0xf9, 0x19, 0xd8, 0xb6, 0x84, 0x0b, 0xce, 0x72, 0x4a, 0x96, 0xd6,
	0xb0, 0x91, 0xbd, 0x77, 0x1c, 0x9d, 0x40, 0x5f, 0x99, 0x92, 0x49, 0xd1, 0x73, 0x49, 0x05, 0xcb,
	0x7d, 0xe8, 0x5a, 0x87, 0x03, 0x11, 0x8a, 0xd8, 0x57, 0x35, 0x88, 0x5e, 0x04, 0x6c, 0x35, 0xb4,
	0x62, 0x69, 0x74, 0x41, 0xf2, 0x0c, 0xfe, 0xcf, 0x90, 0x31, 0x10, 0xa1, 0x17, 0x6f, 0x8e, 0x8e,
	0x93, 0x56, 0xe0, 0x13, 0x2d, 0xb9, 0x46, 0xc6, 0x1b, 0xcd, 0x76, 0xad, 0x2a, 0xba, 0x3c, 0x02,
	0xff, 0xc1, 0x9a, 0x7c, 0x8c, 0xe9, 0x23, 0x05, 0x9d, 0x50, 0xc4, 0x3d, 0xf5, 0x71, 0x20, 0x87,
	0xb0, 0x97, 0xba, 0x61, 0xe6, 0x9e, 0x29, 0xca, 0x31, 0xd3, 0x99, 0x9e, 0x07, 0x5e, 0x28, 0xe2,
	0xae, 0xfa, 0xee, 0x6a, 0x70, 0x0e, 0x7e, 0x2b, 0x21, 0x77, 0xc1, 0x7b, 0xa2, 0x75, 0xe3, 0xdc,
	0x8d, 0x2e, 0xcd, 0x0a, 0x17, 0x65, 0x2d, 0xe5, 0xab, 0x1a, 0x5c, 0x76, 0x2e, 0xc4, 0xe8, 0x55,
	0xc0, 0x8e, 0x6a, 0x3c, 0x4f, 0xc9, 0xae, 0xb2, 0x94, 0xe4, 0x15, 0xf8, 0x13, 0xe2, 0x3b, 0x64,
	0x57, 0xc4, 0xc1, 0x97, 0x48, 0x55, 0x41, 0x83, 0xc3, 0x1f, 0xa2, 0x46, 0xff, 0x86, 0x42, 0x8e,
	0xa1, 0x3f, 0x21, 0x9e, 0xb2, 0x25, 0xcc, 0x33, 0x3d, 0xff, 0xdd, 0x92, 0x5b, 0x90, 0xad, 0x8d,
	0xbf, 0xad, 0xba, 0xdf, 0xa8, 0xbe, 0xfb, 0xf4, 0x2d, 0x00, 0x00, 0xff, 0xff, 0x1d, 0xa9, 0x2f,
	0x9e, 0x00, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RealtimeServiceClient is the client API for RealtimeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RealtimeServiceClient interface {
	//
	//GetLatest
	//returns only latest values from cache then closes.
	GetLatest(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (RealtimeService_GetLatestClient, error)
	//
	//GetStreaming
	//returns any new values in a stream, remains open.
	GetStreaming(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (RealtimeService_GetStreamingClient, error)
	//
	//GetLatestStreaming
	//returns latest values from cache, and any new values, remains open.
	GetLatestStreaming(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (RealtimeService_GetLatestStreamingClient, error)
}

type realtimeServiceClient struct {
	cc *grpc.ClientConn
}

func NewRealtimeServiceClient(cc *grpc.ClientConn) RealtimeServiceClient {
	return &realtimeServiceClient{cc}
}

func (c *realtimeServiceClient) GetLatest(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (RealtimeService_GetLatestClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RealtimeService_serviceDesc.Streams[0], "/realtime.RealtimeService/GetLatest", opts...)
	if err != nil {
		return nil, err
	}
	x := &realtimeServiceGetLatestClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RealtimeService_GetLatestClient interface {
	Recv() (*RouteResponse, error)
	grpc.ClientStream
}

type realtimeServiceGetLatestClient struct {
	grpc.ClientStream
}

func (x *realtimeServiceGetLatestClient) Recv() (*RouteResponse, error) {
	m := new(RouteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *realtimeServiceClient) GetStreaming(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (RealtimeService_GetStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RealtimeService_serviceDesc.Streams[1], "/realtime.RealtimeService/GetStreaming", opts...)
	if err != nil {
		return nil, err
	}
	x := &realtimeServiceGetStreamingClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RealtimeService_GetStreamingClient interface {
	Recv() (*RouteResponse, error)
	grpc.ClientStream
}

type realtimeServiceGetStreamingClient struct {
	grpc.ClientStream
}

func (x *realtimeServiceGetStreamingClient) Recv() (*RouteResponse, error) {
	m := new(RouteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *realtimeServiceClient) GetLatestStreaming(ctx context.Context, in *RouteRequest, opts ...grpc.CallOption) (RealtimeService_GetLatestStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RealtimeService_serviceDesc.Streams[2], "/realtime.RealtimeService/GetLatestStreaming", opts...)
	if err != nil {
		return nil, err
	}
	x := &realtimeServiceGetLatestStreamingClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RealtimeService_GetLatestStreamingClient interface {
	Recv() (*RouteResponse, error)
	grpc.ClientStream
}

type realtimeServiceGetLatestStreamingClient struct {
	grpc.ClientStream
}

func (x *realtimeServiceGetLatestStreamingClient) Recv() (*RouteResponse, error) {
	m := new(RouteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RealtimeServiceServer is the server API for RealtimeService service.
type RealtimeServiceServer interface {
	//
	//GetLatest
	//returns only latest values from cache then closes.
	GetLatest(*RouteRequest, RealtimeService_GetLatestServer) error
	//
	//GetStreaming
	//returns any new values in a stream, remains open.
	GetStreaming(*RouteRequest, RealtimeService_GetStreamingServer) error
	//
	//GetLatestStreaming
	//returns latest values from cache, and any new values, remains open.
	GetLatestStreaming(*RouteRequest, RealtimeService_GetLatestStreamingServer) error
}

// UnimplementedRealtimeServiceServer can be embedded to have forward compatible implementations.
type UnimplementedRealtimeServiceServer struct {
}

func (*UnimplementedRealtimeServiceServer) GetLatest(req *RouteRequest, srv RealtimeService_GetLatestServer) error {
	return status.Errorf(codes.Unimplemented, "method GetLatest not implemented")
}
func (*UnimplementedRealtimeServiceServer) GetStreaming(req *RouteRequest, srv RealtimeService_GetStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method GetStreaming not implemented")
}
func (*UnimplementedRealtimeServiceServer) GetLatestStreaming(req *RouteRequest, srv RealtimeService_GetLatestStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method GetLatestStreaming not implemented")
}

func RegisterRealtimeServiceServer(s *grpc.Server, srv RealtimeServiceServer) {
	s.RegisterService(&_RealtimeService_serviceDesc, srv)
}

func _RealtimeService_GetLatest_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RouteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RealtimeServiceServer).GetLatest(m, &realtimeServiceGetLatestServer{stream})
}

type RealtimeService_GetLatestServer interface {
	Send(*RouteResponse) error
	grpc.ServerStream
}

type realtimeServiceGetLatestServer struct {
	grpc.ServerStream
}

func (x *realtimeServiceGetLatestServer) Send(m *RouteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RealtimeService_GetStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RouteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RealtimeServiceServer).GetStreaming(m, &realtimeServiceGetStreamingServer{stream})
}

type RealtimeService_GetStreamingServer interface {
	Send(*RouteResponse) error
	grpc.ServerStream
}

type realtimeServiceGetStreamingServer struct {
	grpc.ServerStream
}

func (x *realtimeServiceGetStreamingServer) Send(m *RouteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RealtimeService_GetLatestStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RouteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RealtimeServiceServer).GetLatestStreaming(m, &realtimeServiceGetLatestStreamingServer{stream})
}

type RealtimeService_GetLatestStreamingServer interface {
	Send(*RouteResponse) error
	grpc.ServerStream
}

type realtimeServiceGetLatestStreamingServer struct {
	grpc.ServerStream
}

func (x *realtimeServiceGetLatestStreamingServer) Send(m *RouteResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _RealtimeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "realtime.RealtimeService",
	HandlerType: (*RealtimeServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetLatest",
			Handler:       _RealtimeService_GetLatest_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetStreaming",
			Handler:       _RealtimeService_GetStreaming_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetLatestStreaming",
			Handler:       _RealtimeService_GetLatestStreaming_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "realtime.proto",
}
